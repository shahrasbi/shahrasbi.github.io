<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Amirbehshad  Shahrasbi | Publications</title>
<meta name="description" content="">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/publications/">

<!-- Theming-->


    
<!-- MathJax -->
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="http://localhost:4000//">
       <span class="font-weight-bold">Amirbehshad</span>   Shahrasbi
      </a>
      
      <!-- Navbar Toogle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              Bio
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/CV/">
                CV
                
              </a>
          </li>
          
          
          
          <li class="nav-item active">
              <a class="nav-link" href="/publications/">
                Publications
                
                <span class="sr-only">(current)</span>
                
              </a>
          </li>
          
          
          
          
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      <div class="post">

  <header class="post-header">
    <h1 class="post-title">Publications</h1>
    <p class="post-description"></p>
  </header>

  <article>
    <h3>Conference Papers</h3>

<div class="publications">


  <h2 class="year">2020</h2>
  <ol class="bibliography"><li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">STOC</abbr>
    
  
  </div>

  <div id="guruswami2019optimally" class="col-sm-8">
    
      <div class="title">Optimally Resilient Codes for List-Decoding from Insertions and Deletions</div>
      <div class="author">
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~venkatg/" target="_blank">Guruswami, V.</a>,
                
              
            
          
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~haeupler/" target="_blank">Haeupler, B.</a>,
                
              
            
          
        
          
            
              
	      and <em>Shahrasbi, A.</em>
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of the ACM Symposium on Theory of Computing (STOC)</em>
      
      
        2020
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/1909.10683" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="guruswami2019optimally" onclick="toggle_visibility('guruswami2019optimally-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="guruswami2019optimally-bibtex" style="display:none;">
    <pre>@inproceedings{guruswami2019optimally,
  author = {Guruswami, Venkatesan and Haeupler, Bernhard and Shahrasbi, Amirbehshad},
  title = {Optimally Resilient Codes for List-Decoding from Insertions and Deletions},
  booktitle = {Proceedings of the ACM Symposium on Theory of Computing (STOC)},
  pages = {524--537},
  year = {2020},
  abbr = {STOC},
  arxiv = {1909.10683}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We give a complete answer to the following basic question: "What is the maximal fraction of deletions or insertions tolerable by q-ary list-decodable codes with non-vanishing information rate?"<br />
This question has been open even for binary codes, including the restriction to the binary insertion-only setting, where the best known results was that a \(γ≤0.707\)&nbsp;fraction of insertions is tolerable by some binary code family.<br />
For any desired \(\varepsilon&gt;0\), we construct a family of binary codes of positive rate which can be efficiently list-decoded from any combination of \(γ\)&nbsp;fraction of insertions and \(δ\)&nbsp;fraction of deletions as long as \(γ+2δ≤1-\varepsilon\). On the other hand, for any \(γ, δ\)&nbsp;with \(γ+2δ=1\)&nbsp;list-decoding is impossible. Our result thus precisely characterizes the feasibility region of binary list-decodable codes for insertions and deletions.<br />
We further generalize our result to codes over any finite alphabet of size \(q\). Surprisingly, our work reveals that the feasibility region for \(q&gt;2\)&nbsp;is not the natural generalization of the binary bound above. We provide tight upper and lower bounds that precisely pin down the feasibility region, which turns out to have a \((q-1\))-piece-wise linear boundary whose \(q\)&nbsp;corner-points lie on a quadratic curve.<br />
The main technical work in our results is proving the existence of code families of sufficiently large size with good list-decoding properties for any combination of \(δ, γ\)&nbsp;within the claimed feasibility region. We achieve this via an intricate analysis of codes introduced by [Bukh, Ma; SIAM J. Discrete Math; 2014]. Finally we give a simple yet powerful concatenation scheme for list-decodable insertion-deletion codes which transforms any such (non-efficient) code family (with vanishing information rate) into an efficiently decodable code family with constant rate.</p>
    </div>
    
  </div>
</div>



</li></ol>

  <h2 class="year">2019</h2>
  <ol class="bibliography"><li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">STOC</abbr>
    
  
  </div>

  <div id="haeupler2019near" class="col-sm-8">
    
      <div class="title">Near-Linear Time Insertion-Deletion Codes and (1+\(\varepsilon\))-Approximating Edit Distance via Indexing</div>
      <div class="author">
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~haeupler/" target="_blank">Haeupler, B.</a>,
                
              
            
          
        
          
            
              
                
                  <a href="https://cs.stanford.edu/~aviad/" target="_blank">Rubinstein, A.</a>,
                
              
            
          
        
          
            
              
	      and <em>Shahrasbi, A.</em>
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of the ACM Symposium on Theory of Computing (STOC)</em>
      
      
        2019
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/1810.11863" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="haeupler2019near" onclick="toggle_visibility('haeupler2019near-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="haeupler2019near-bibtex" style="display:none;">
    <pre>@inproceedings{haeupler2019near,
  title = {Near-Linear Time Insertion-Deletion Codes and (1+\(\varepsilon\))-Approximating Edit Distance via Indexing},
  author = {Haeupler, Bernhard and Rubinstein, Aviad and Shahrasbi, Amirbehshad},
  booktitle = {Proceedings of the ACM Symposium on Theory of Computing (STOC)},
  pages = {697--708},
  year = {2019},
  abbr = {STOC},
  arxiv = {1810.11863}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We introduce <i>fast-decodable indexing schemes for edit distance</i> which can be used to speed up edit distance computations to near-linear time if one of the strings is indexed by an indexing string \(I\). In particular, for every length \(n\)&nbsp;and every \(\varepsilon &gt;0\), one can in near linear time construct a string \(I ∈Σ’^n\)&nbsp;with \(|Σ’| = O_\varepsilon(1)\), such that, indexing any string \(S ∈Σ^n\), symbol-by-symbol, with \(I\)&nbsp;results in a string \(S’ ∈Σ’^\prime\)<sup>\(n\)</sup>&nbsp;where \(Σ’^\prime = Σ\times Σ’\)&nbsp;for which edit distance computations are easy, i.e., one can compute a 
\((1+\varepsilon)\)-approximation of the edit distance between \(S’\)&nbsp;and any other string in \(O(n⋅polylog(n))\)&nbsp;time.

Our indexing schemes can be used to improve the decoding complexity of state-of-the-art error correcting codes for insertion and deletions. In particular, they lead to near-linear time decoding algorithms for the insertion-deletion codes of [Haeupler, Shahrasbi; STOC ’17] and list-decodable insertion-deletion codes of [Haeupler, Shahrasbi, Sudan; ICALP ‘18]. Interestingly, the latter codes are a crucial ingredient in the construction of fast-decodable indexing schemes.</p>
    </div>
    
  </div>
</div>



</li>
<li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">SODA</abbr>
    
  
  </div>

  <div id="cheng2018synchronization" class="col-sm-8">
    
      <div class="title">Synchronization Strings: Highly Efficient Deterministic Constructions over Small Alphabets</div>
      <div class="author">
        
          
            
              
                
                  <a href="https://sites.google.com/site/ckkcdh/home" target="_blank">Cheng, K.</a>,
                
              
            
          
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~haeupler/" target="_blank">Haeupler, B.</a>,
                
              
            
          
        
          
            
              
                
                  <a href="https://www.cs.jhu.edu/~lixints/" target="_blank">Li, X.</a>,
                
              
            
          
        
          
            
              
	      <em>Shahrasbi, A.</em>,
              
            
          
        
          
            
              
                
                  and <a href="" target="_blank">Wu, K.</a>
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of the ACM-SIAM Symposium on Discrete Algorithms (SODA)</em>
      
      
        2019
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/1803.03530" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="cheng2018synchronization" onclick="toggle_visibility('cheng2018synchronization-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="cheng2018synchronization-bibtex" style="display:none;">
    <pre>@inproceedings{cheng2018synchronization,
  title = {Synchronization Strings: Highly Efficient Deterministic Constructions over Small Alphabets},
  author = {Cheng, Kuan and Haeupler, Bernhard and Li, Xin and Shahrasbi, Amirbehshad and Wu, Ke},
  booktitle = {Proceedings of the ACM-SIAM Symposium on Discrete Algorithms (SODA)},
  pages = {2185--2204},
  year = {2019},
  abbr = {SODA},
  arxiv = {1803.03530}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Synchronization strings are recently introduced by Haeupler and Shahrasbi [STOC 2017] in the study of codes for correcting insertion and deletion errors (insdel codes). A synchronization string is an encoding of the indices of the symbols in a string, and together with an appropriate decoding algorithm it can transform insertion and deletion errors into standard symbol erasures and corruptions. This reduces the problem of constructing insdel codes to the problem of constructing standard error correcting codes, which is much better understood. Besides this, synchronization strings are also useful in other applications such as synchronization sequences and interactive coding schemes. For all such applications, synchronization strings are desired to be over alphabets that are as small as possible, since a larger alphabet size corresponds to more redundant information added.<br />

											Haeupler and Shahrasbi [STOC 2017] showed that for any  parameter \(\varepsilon&gt;0\), synchronization strings of arbitrary length exist over an alphabet whose size depends only on \(\varepsilon\). Specifically, Haeupler and Shahrasbi [STOC 2017] obtained an alphabet size of \(O(\varepsilon\)<sup>\(-4\)</sup>\()\), which left an open question on where the minimal size of such alphabets lies between \(Ω(\varepsilon\)<sup>\(-1\)</sup>\()\)&nbsp;and \(O(\varepsilon\)<sup>\(-4\)</sup>\()\). In this work, we partially bridge this gap by providing an improved lower bound of \(Ω(\varepsilon\)<sup>\(-3/2\)</sup>\()\), and an improved upper bound of \(O(\varepsilon\)<sup>\(-2\)</sup>\()\). We also provide fast explicit constructions of synchronization strings over small alphabets.<br />

Further, along the lines of previous work on similar combinatorial objects, we study the extremal question of the smallest possible alphabet size over which synchronization strings can exist for some constant \(\varepsilon &lt; 1\). We show that one can construct \(\varepsilon\)-synchronization strings over alphabets of size four while no such string exists over binary alphabets. This reduces the extremal question to whether synchronization strings exist over ternary alphabets.</p>
    </div>
    
  </div>
</div>



</li></ol>

  <h2 class="year">2018</h2>
  <ol class="bibliography"><li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">ICALP</abbr>
    
  
  </div>

  <div id="haeupler2018synchronization4" class="col-sm-8">
    
      <div class="title">Synchronization Strings: List Decoding for Insertions and Deletions</div>
      <div class="author">
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~haeupler/" target="_blank">Haeupler, B.</a>,
                
              
            
          
        
          
            
              
	      <em>Shahrasbi, A.</em>,
              
            
          
        
          
            
              
                
                  and <a href="https://madhu.seas.harvard.edu/" target="_blank">Sudan, M.</a>
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of the International Conference on Automata, Languages, and Programming (ICALP)</em>
      
      
        2018
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/1802.08663" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="haeupler2018synchronization4" onclick="toggle_visibility('haeupler2018synchronization4-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="haeupler2018synchronization4-bibtex" style="display:none;">
    <pre>@inproceedings{haeupler2018synchronization4,
  title = {Synchronization Strings: List Decoding for Insertions and Deletions},
  author = {Haeupler, Bernhard and Shahrasbi, Amirbehshad and Sudan, Madhu},
  booktitle = {Proceedings of the International Conference on Automata, Languages, and Programming (ICALP)},
  year = {2018},
  abbr = {ICALP},
  arxiv = {1802.08663}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We study codes that are list-decodable under insertions and deletions ("insdel codes"). Specifically, we consider the setting where, given a codeword \(x\)&nbsp;of length \(n\)&nbsp;over some finite alphabet \(Σ\)&nbsp;of size \(q\), \(δn\)&nbsp;codeword symbols may be adversarially deleted and \(γ⋅n\)symbols may be adversarially inserted to yield a corrupted word \(w\). A code is said to be list-decodable if there is an (efficient) algorithm that, given \(w\), reports a small list of codewords that include the original codeword \(x\). Given \(δ\)&nbsp;and \(γ\)&nbsp;we study what is the rate \(R\)&nbsp;for which there exists a constant \(q\)&nbsp;and list size \(L\)&nbsp;such that there exist codes of rate \(R\)&nbsp;correcting \(δ\)-fraction insertions and \(γ\)-fraction deletions while reporting lists of size at most \(L\).<br />


											Using the concept of <i>synchronization strings</i>, introduced by the first two authors [Proc. STOC 2017], we show some surprising results. We show that for every \(0≤δ&lt; 1\), every \(0 ≤γ&lt; ∞\)&nbsp;and every \(ε&gt; 0\)&nbsp;there exists codes of rate \(1 - δ- ε\)&nbsp;and constant alphabet (so \(q = O_δ,γ,ε(1)\)) and sub-polynomial list sizes. Furthermore our codes are accompanied by efficient (polynomial time) decoding algorithms. We stress that the fraction of insertions can be arbitrarily large (more than 100%), and the rate is independent of this parameter. We also prove several tight bounds on the parameters of list-decodable insdel codes. In particular we show that the alphabet size of insdel codes needs to be exponentially large in \(ε^-\)\(^1\), where \(ε\)&nbsp;is the gap to capacity above. Our result even applies to settings where the unique-decoding capacity equals the list-decoding  capacity and when it does so, it shows that the alphabet size needs to be exponentially large in the gap to capacity. This is sharp contrast to the Hamming error model where alphabet size polynomial in \(ε^-\)\(^1\)&nbsp;suffices for unique decoding. This lower bound also shows that the exponential dependence on the alphabet size in previous works that constructed insdel codes is actually necessary! <br />

Our result sheds light on the remarkable asymmetry between the impact of insertions and deletions from the point of view of error-correction: Whereas deletions cost in the rate of the code, insertion costs are borne by the adversary and not the code! Our results also highlight the dominance of the model of insertions and deletions over the Hamming model: A Hamming error is equal to one insertion and one deletion (at the same location). Thus the effect of \(δ\)-fraction Hamming errors can be simulated by \(δ\)-fraction of deletions and \(δ\)-fraction of insertions &mdash; but insdel codes can deal with much more insertions without loss in rate (though at the price of higher alphabet size).</p>
    </div>
    
  </div>
</div>



</li>
<li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">STOC</abbr>
    
  
  </div>

  <div id="haeupler2017synchronization3" class="col-sm-8">
    
      <div class="title">Synchronization Strings: Explicit Constructions, Local Decoding, and Applications</div>
      <div class="author">
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~haeupler/" target="_blank">Haeupler, B.</a>,
                
              
            
          
        
          
            
              
	      and <em>Shahrasbi, A.</em>
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of the ACM Symposium on Theory of Computing (STOC)</em>
      
      
        2018
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/1710.09795" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="haeupler2017synchronization3" onclick="toggle_visibility('haeupler2017synchronization3-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="haeupler2017synchronization3-bibtex" style="display:none;">
    <pre>@inproceedings{haeupler2017synchronization3,
  title = {Synchronization Strings: Explicit Constructions, Local Decoding, and Applications},
  author = {Haeupler, Bernhard and Shahrasbi, Amirbehshad},
  booktitle = {Proceedings of the ACM Symposium on Theory of Computing (STOC)},
  pages = {841--854},
  year = {2018},
  abbr = {STOC},
  arxiv = {1710.09795}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>This paper gives new results for <b>synchronization strings</b>, a powerful combinatorial object that allows to efficiently deal with insertions and deletions in various communication problems:
<ul style="list-style-type:disc" align="left">
	<li>We give a <b>deterministic, linear time synchronization string construction</b>, improving over an \(O(n^5)\)&nbsp;time randomized construction. Independently of this work, a deterministic \(O(n \log^2 \log n)\)&nbsp;time construction proposed by Cheng, Li, and Wu.</li>
	<li>We give a <b>deterministic construction of an infinite synchronization string</b> which outputs the first \(n\)&nbsp;symbols in \(O(n)\)&nbsp;time. Previously it was not known whether such a string was computable.</li>
	<li> Both synchronization string constructions are <b>highly explicit</b>, i.e., the \(i\)th symbol can be deterministically computed in \(O(\log i)\)&nbsp;time. </li>
	<li> This paper also introduces a generalized notion we call <b>long-distance synchronization strings</b>. Such strings <b>allow for local and very fast decoding</b>. In particular, only \(O(\log^3 n)\)&nbsp;time and access to logarithmically many symbols is required to decode any index.</li>
</ul>
The paper also provides several applications for these improved synchronization strings:
<ul style="list-style-type:disc" align="left">
	<li>For any \(δ&lt; 1\)&nbsp;and \(ε&gt; 0\)&nbsp;we provide an <b>insdel error correcting block code</b> with rate \(1 - δ- ε\)&nbsp;which can correct any \(O(δ)\)&nbsp;fraction of insertion and deletion errors in \(O(n \log^3 n)\)&nbsp;time. This <b>near linear computational efficiency</b> is surprising given that we do not even know how to compute the (edit) distance between the decoding input and output in sub-quadratic time.</li>
	<li>We show that local decodability implies that error correcting codes constructed with long-distance synchronization strings can not only efficiently recover from \(δ\)&nbsp;fraction of insdel errors but, similar to [Schulman, Zuckerman; TransInf’99], also from any \(O(δ/ \log n)\)&nbsp;fraction of <b>block transpositions and block replications</b>. These block corruptions allow arbitrarily long substrings to be swapped or replicated anywhere.</li>
	<li>We show that highly explicitness and local decoding allow for <b>infinite channel simulations with   exponentially smaller memory and decoding time requirements</b>. These simulations can then be used to give the first <b>near linear time interactive coding scheme for insdel errors</b>, similar to the result of [Brakerski, Naor; SODA’13] for Hamming errors. 
</li></ul></p>
    </div>
    
  </div>
</div>



</li>
<li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">ICALP</abbr>
    
  
  </div>

  <div id="haeupler2017synchronization2" class="col-sm-8">
    
      <div class="title">Synchronization Strings: Channel Simulations and Interactive Coding for Insertions and Deletions</div>
      <div class="author">
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~haeupler/" target="_blank">Haeupler, B.</a>,
                
              
            
          
        
          
            
              
	      <em>Shahrasbi, A.</em>,
              
            
          
        
          
            
              
                
                  and <a href="https://vitercik.github.io/" target="_blank">Vitercik, E.</a>
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of the International Conference on Automata, Languages, and Programming (ICALP)</em>
      
      
        2018
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/1707.04233" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="haeupler2017synchronization2" onclick="toggle_visibility('haeupler2017synchronization2-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="haeupler2017synchronization2-bibtex" style="display:none;">
    <pre>@inproceedings{haeupler2017synchronization2,
  author = {Haeupler, Bernhard and Shahrasbi, Amirbehshad and Vitercik, Ellen},
  title = {Synchronization Strings: Channel Simulations and Interactive Coding for Insertions and Deletions},
  booktitle = {Proceedings of the International Conference on Automata, Languages, and Programming (ICALP)},
  pages = {75:1--75:14},
  year = {2018},
  abbr = {ICALP},
  arxiv = {1707.04233}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We present many new results related to reliable (interactive) communication
over insertion-deletion channels. Synchronization errors, such as insertions
and deletions, strictly generalize the usual symbol corruption errors and are
much harder to protect against.
<br />We show how to hide the complications of synchronization errors in many
applications by introducing very general channel simulations which efficiently
transform an insertion-deletion channel into a regular symbol corruption
channel with an error rate larger by a constant factor and a slightly smaller
alphabet. We generalize synchronization string based methods which were
recently introduced as a tool to design essentially optimal error correcting
codes for insertion-deletion channels. Our channel simulations depend on the
fact that, at the cost of increasing the error rate by a constant factor,
synchronization strings can be decoded in a streaming manner that preserves
linearity of time. We also provide a lower bound showing that this constant
factor cannot be improved to \(1+ε\), in contrast to what is achievable
for error correcting codes. Our channel simulations drastically generalize the
applicability of synchronization strings.
<br />We provide new interactive coding schemes which simulate any interactive
two-party protocol over an insertion-deletion channel. Our results improve over
the interactive coding scheme of Braverman et al. which achieves a small
constant rate and requires exponential time computations. We provide the first
computationally efficient interactive coding schemes for synchronization
errors, the first coding scheme with a rate approaching one for small noise
rates, and also improve over the maximal tolerable error rate. We also show
tight connections between synchronization strings and edit-distance tree codes
which allow us to transfer results from tree codes directly to edit-distance
tree codes.</p>
    </div>
    
  </div>
</div>



</li></ol>

  <h2 class="year">2017</h2>
  <ol class="bibliography"><li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">STOC</abbr>
    
  
  </div>

  <div id="haeupler2017synchronization" class="col-sm-8">
    
      <div class="title">Synchronization Strings: Codes for Insertions and Deletions Approaching the Singleton Bound</div>
      <div class="author">
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~haeupler/" target="_blank">Haeupler, B.</a>,
                
              
            
          
        
          
            
              
	      and <em>Shahrasbi, A.</em>
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of the ACM Symposium on Theory of Computing (STOC)</em>
      
      
        2017
      
      </div>
    

    
    <b><i> Invited to be published in the Theory of Computing journal </i></b>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/1704.00807" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="haeupler2017synchronization" onclick="toggle_visibility('haeupler2017synchronization-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="haeupler2017synchronization-bibtex" style="display:none;">
    <pre>@inproceedings{haeupler2017synchronization,
  title = {Synchronization Strings: Codes for Insertions and Deletions Approaching the {Singleton} Bound},
  author = {Haeupler, Bernhard and Shahrasbi, Amirbehshad},
  booktitle = {Proceedings of the ACM Symposium on Theory of Computing (STOC)},
  pages = {33--46},
  year = {2017},
  abbr = {STOC},
  arxiv = {1704.00807},
  notes = {Invited to be published in the Theory of Computing journal}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We introduce <i>synchronization strings</i> as a novel way of efficiently dealing
with synchronization errors, i.e., insertions and deletions. Synchronization
errors are strictly more general and much harder to deal with than commonly
considered half-errors, i.e., symbol corruptions and erasures. For every
\(ε&gt;0\), synchronization strings allow to index a sequence with an
\(ε\)<sup>\(-O(1)\)</sup>&nbsp;size alphabet such that one can efficiently transform \(k\)&nbsp;
 synchronization errors into \((1+ε)k\)&nbsp;half-errors. This powerful new
technique has many applications. In this paper, we focus on designing insdel
codes, i.e., error correcting block codes (ECCs) for insertion deletion
channels.
<br />While ECCs for both half-errors and synchronization errors have been
intensely studied, the later has largely resisted progress. Indeed, it took
until 1999 for the first insdel codes with constant rate, constant distance,
and constant alphabet size to be constructed by Schulman and Zuckerman. Insdel
codes for asymptotically large or small noise rates were given in 2016 by
Guruswami et al. but these codes are still polynomially far from the optimal
rate-distance tradeoff. This makes the understanding of insdel codes up to this
work equivalent to what was known for regular ECCs after Forney introduced
concatenated codes in his doctoral thesis 50 years ago.
<br />A direct application of our synchronization strings based indexing method
gives a simple black-box construction which transforms any ECC into an equally
efficient insdel code with a slightly larger alphabet size. This instantly
transfers much of the highly developed understanding for regular ECCs over
large constant alphabets into the realm of insdel codes. Most notably, we
obtain efficient insdel codes which get arbitrarily close to the optimal
rate-distance tradeoff given by the Singleton bound for the complete noise
spectrum.</p>
    </div>
    
  </div>
</div>



</li></ol>

  <h2 class="year">2014</h2>
  <ol class="bibliography"><li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">ISIT</abbr>
    
  
  </div>

  <div id="tahmasbi2014critical" class="col-sm-8">
    
      <div class="title">Critical Graphs in Index Coding</div>
      <div class="author">
        
          
            
              
                
                  Tahmasbi, M.,
                
              
            
          
        
          
            
              
	      <em>Shahrasbi, A.</em>,
              
            
          
        
          
            
              
                
                  and <a href="http://sharif.edu/~aminzadeh/" target="_blank">Gohari, A.</a>
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In IEEE International Symposium on Information Theory (ISIT)</em>
      
      
        2014
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/1312.0132" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="tahmasbi2014critical" onclick="toggle_visibility('tahmasbi2014critical-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="tahmasbi2014critical-bibtex" style="display:none;">
    <pre>@inproceedings{tahmasbi2014critical,
  title = {Critical Graphs in Index Coding},
  author = {Tahmasbi, Mehrdad and Shahrasbi, Amirbehshad and Gohari, Amin},
  booktitle = {IEEE International Symposium on Information Theory (ISIT)},
  pages = {281--285},
  year = {2014},
  organization = {IEEE},
  abbr = {ISIT},
  arxiv = {1312.0132}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>In this paper we define critical graphs as minimal graphs that support a given set of rates for the index coding problem, and study them for both the one-shot and asymptotic setups. For the case of equal rates, we find the critical graph with minimum number of edges for both one-shot and asymptotic cases. For the general case of possibly distinct rates, we show that for one-shot and asymptotic linear index coding, as well as asymptotic non-linear index coding, each critical graph is a union of disjoint strongly connected subgraphs (USCS). On the other hand, we identify a non-USCS critical graph for a one-shot non-linear index coding problem. Next, we identify a few graph structures that are critical. We also generalize some of our results to the groupcast problem. In addition, we show that the capacity region of the index coding is additive for union of disjoint graphs.</p>
    </div>
    
  </div>
</div>



</li></ol>


</div>

<p><br /></p>
<h3>Journal Papers</h3>

<div class="publications">

  <h2 class="year">2014</h2>
  <ol class="bibliography"><li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">JSAC</abbr>
    
  
  </div>

  <div id="tahmasbi2014criticalJournal" class="col-sm-8">
    
      <div class="title">Critical graphs in Index Coding</div>
      <div class="author">
        
          
            
              
                
                  Tahmasbi, M.,
                
              
            
          
        
          
            
              
	      <em>Shahrasbi, A.</em>,
              
            
          
        
          
            
              
                
                  and <a href="http://sharif.edu/~aminzadeh/" target="_blank">Gohari, A.</a>
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>IEEE Journal on Selected areas in Communications,</em>
      
      
        2014
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/1312.0132" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="tahmasbi2014criticalJournal" onclick="toggle_visibility('tahmasbi2014criticalJournal-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="tahmasbi2014criticalJournal-bibtex" style="display:none;">
    <pre>@article{tahmasbi2014criticalJournal,
  title = {Critical graphs in Index Coding},
  author = {Tahmasbi, M. and Shahrasbi, A. and Gohari, A.},
  journal = {IEEE Journal on Selected areas in Communications,},
  volume = {33},
  number = {2},
  pages = {225--235},
  year = {2014},
  abbr = {JSAC},
  arxiv = {1312.0132}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>In this paper we define critical graphs as minimal graphs that support a given set of rates for the index coding problem, and study them for both the one-shot and asymptotic setups. For the case of equal rates, we find the critical graph with minimum number of edges for both one-shot and asymptotic cases. For the general case of possibly distinct rates, we show that for one-shot and asymptotic linear index coding, as well as asymptotic non-linear index coding, each critical graph is a union of disjoint strongly connected subgraphs (USCS). On the other hand, we identify a non-USCS critical graph for a one-shot non-linear index coding problem. Next, we identify a few graph structures that are critical. We also generalize some of our results to the groupcast problem. In addition, we show that the capacity region of the index coding is additive for union of disjoint graphs.</p>
    </div>
    
  </div>
</div>



</li></ol>

</div>

<p><br /></p>
<h3>Manuscripts</h3>
<div class="publications">

  <h2 class="year">2020</h2>
  <ol class="bibliography"><li><div class="row">
  <div class="col-sm-2 abbr">
  
    
    <abbr class="badge">Ph.D. Thesis</abbr>
    
  
  </div>

  <div id="ShahrasbiThesis" class="col-sm-8">
    
      <div class="title">Coding for Synchronization Errors</div>
      <div class="author">
        
          
            
	    <em>Shahrasbi, A.</em>
            
          
        
      </div>

      <div class="periodical">
      
      
        2020
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
    
      
      <a href="/assets/pdf/Coding%20for%20Synchronization%20Errors.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="ShahrasbiThesis" onclick="toggle_visibility('ShahrasbiThesis-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="ShahrasbiThesis-bibtex" style="display:none;">
    <pre>@phdthesis{ShahrasbiThesis,
  title = {Coding for Synchronization Errors},
  author = {Shahrasbi, Amirbehshad},
  year = {2020},
  school = {Carnegie Mellon University},
  abbr = {Ph.D. Thesis},
  pdf = {Coding for Synchronization Errors.pdf}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Coding theory is the study of algorithms and techniques that facilitate reliable information transmission over noisy mediums, most notably through combinatorial objects called error-correcting codes. Following the inspiring works of Shannon and Hamming, a sophisticated and extensive body of research on error-correcting codes has led to a deep and detailed theoretical understanding as well as practical implementations that have helped fuel the digital revolution. Error-correcting codes can be found in essentially all modern communication, computation, and data storage systems. While being remarkably successful in understanding the theoretical limits and trade-offs of reliable communication under errors and erasures, the coding theory literature significantly lags behind when it comes to overcoming errors that concern the timing of communications. In particular, the study of correcting synchronization errors, i.e., symbol insertions and deletions, while initially introduced by Levenshtein in the 60s, has significantly fallen behind our highly sophisticated knowledge of codes for Hamming-type errors.<br />

This thesis investigates coding against synchronization errors under a variety of models and attempts to understand trade-offs between different qualities of interest in respective coding schemes such as rate, distance, and algorithmic qualities of the code. Most of the presented results rely on synchronization strings, simple yet powerful pseudorandom objects introduced in this work that have proven to be very effective solutions for coping with synchronization errors in various settings.<br />

Through indexing with strings that satisfy certain pseudo-random properties, we provide synchronization codes that achieve near-optimal rate-distance trade-off. We further attempt to provide constructions that enable fast encoding/decoding procedures. We study the same problem under the list-decoding regime, where the decoder is expected to provide a short list of codewords that is guaranteed to contain the sent message. We will also try to better understand the fundamental limits of list-decoding for synchronization errors such as the list-decoding capacity or maximal error resilience for list-decodable synchronization codes. This thesis furthermore studies synchronization strings and other related pseudo-random string properties as combinatorial objects that are of independent interest. Such combinatorial objects will be used to extend some of our techniques to alternative communication problems such as coding from block transposition errors or coding for interactive communication.</p>
    </div>
    
  </div>
</div>



</li>
<li><div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="haeupler-list-dec-capacity2020" class="col-sm-8">
    
      <div class="title">Rate-Distance Trade-offs for List-Decodable Insertion-Deletion Codes</div>
      <div class="author">
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~haeupler/" target="_blank">Haeupler, B.</a>,
                
              
            
          
        
          
            
              
	      and <em>Shahrasbi, A.</em>
              
            
          
        
      </div>

      <div class="periodical">
      
        <em></em>
      
      
        2020
      
      </div>
    

    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      <a href="http://arxiv.org/abs/2009.13307" class="btn btn-sm z-depth-0" role="button" target="_blank">arXiv</a>
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="haeupler-list-dec-capacity2020" onclick="toggle_visibility('haeupler-list-dec-capacity2020-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="haeupler-list-dec-capacity2020-bibtex" style="display:none;">
    <pre>@article{haeupler-list-dec-capacity2020,
  title = {Rate-Distance Trade-offs for List-Decodable Insertion-Deletion Codes},
  author = {Haeupler, Bernhard and Shahrasbi, Amirbehshad},
  year = {2020},
  arxiv = {2009.13307}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>This paper presents general bounds on the highest achievable rate for list-decodable insertion-deletion codes. In particular, we give novel outer and inner bounds for the highest achievable communication rate of any insertion-deletion code that can be list-decoded from any \(γ\)&nbsp;fraction of insertions and any \(δ\)&nbsp;fraction of deletions. Our bounds simultaneously generalize the known bounds for the previously studied special cases of insertion-only, deletion-only, and zero-rate and correct other bounds reported for the general case.</p>
    </div>
    
  </div>
</div>



</li>
<li><div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="Review Paper" class="col-sm-8">
    
      <div class="title">Synchronization Strings and Codes for Insertions and Deletions – a Survey</div>
      <div class="author">
        
          
            
              
                
                  <a href="http://www.cs.cmu.edu/~haeupler/" target="_blank">Haeupler, B.</a>,
                
              
            
          
        
          
            
              
	      and <em>Shahrasbi, A.</em>
              
            
          
        
      </div>

      <div class="periodical">
      
        <em></em>
      
      
        2020
      
      </div>
    

    
    <b><i> Invited to IEEE Transactions on Information Theory: Special Issue Dedicated to the Memory of Vladimir I. Levenshtein </i></b>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
    
    
    
    
    
    
    
	
	
<script type="text/javascript">
   function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
	   e.style.display = 'block';
   }
</script>

    <a class="btn btn-sm z-depth-0" role="button" id="Review Paper" onclick="toggle_visibility('Review Paper-bibtex');">BibTex</a>
    <div class="dropDownBibtex" id="Review Paper-bibtex" style="display:none;">
    <pre>@article{Review Paper,
  title = {Synchronization Strings and Codes for Insertions and Deletions -- a Survey},
  author = {Haeupler, Bernhard and Shahrasbi, Amirbehshad},
  year = {2020},
  notes = {Invited to IEEE Transactions on Information Theory: Special Issue Dedicated to the Memory of Vladimir I. Levenshtein}
}
</pre>
    </div>

    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Already in the 1960s, Levenshtein and others studied error-correcting codes that protect against synchronization errors, such as symbol insertions and deletions. However, despite significant efforts, progress on designing such codes has been lagging until recently, particularly compared to the detailed understanding of error-correcting codes for symbol substitution or erasure errors. This paper surveys the recent progress in designing efficient error-correcting codes over finite alphabets that can correct a constant fraction of worst-case insertions and deletions. <br />

Most state-of-the-art results for such codes rely on synchronization strings, simple yet powerful pseudo-random objects that have proven to be very effective solutions for coping with synchronization errors in various settings. This survey also includes an overview of what is known about synchronization strings and discusses communication settings related to error-correcting codes in which synchronization strings have been applied.</p>
    </div>
    
  </div>
</div>



</li></ol>

</div>


  </article>

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2020 Amirbehshad  Shahrasbi.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
  </div>
</footer>


<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11544322; 
var sc_invisible=1; 
var sc_security="18d3f964"; 
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11544322/0/18d3f964/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->



  </body>

  <!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  



<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>

<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>


</html>
